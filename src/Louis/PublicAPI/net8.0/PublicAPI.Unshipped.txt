#nullable enable
*REMOVED*virtual Louis.Threading.AsyncService.LogSetupCompleted() -> void
*REMOVED*virtual Louis.Threading.AsyncService.SetupAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask
*REMOVED*Louis.Threading.AsyncService.StartAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>!
*REMOVED*Louis.Threading.AsyncService.StopAsync() -> System.Threading.Tasks.Task<bool>!
*REMOVED*Louis.Threading.AsyncService.WaitUntilStartedAsync() -> System.Threading.Tasks.Task<bool>!
Louis.ComponentModel.ParsableStringConverter<T>
Louis.ComponentModel.ParsableStringConverter<T>.ParsableStringConverter() -> void
Louis.IO.ReadOnlyMemoryStream
Louis.IO.ReadOnlyMemoryStream.ReadOnlyMemoryStream(System.ReadOnlyMemory<byte> data) -> void
Louis.Threading.AsyncService.StartAndWaitAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Louis.Threading.AsyncServiceSetupResult>!
Louis.Threading.AsyncService.WaitUntilStartedAsync() -> System.Threading.Tasks.Task<Louis.Threading.AsyncServiceSetupResult>!
Louis.Threading.AsyncServiceSetupResult
Louis.Threading.AsyncServiceSetupResult.Canceled = 3 -> Louis.Threading.AsyncServiceSetupResult
Louis.Threading.AsyncServiceSetupResult.Faulted = 4 -> Louis.Threading.AsyncServiceSetupResult
Louis.Threading.AsyncServiceSetupResult.NotStarted = 1 -> Louis.Threading.AsyncServiceSetupResult
Louis.Threading.AsyncServiceSetupResult.Successful = 0 -> Louis.Threading.AsyncServiceSetupResult
Louis.Threading.AsyncServiceSetupResult.Unsuccessful = 2 -> Louis.Threading.AsyncServiceSetupResult
Louis.Threading.InterlockedFlag.Equals(bool other) -> bool
Louis.Threading.InterlockedReference<T>
Louis.Threading.InterlockedReference<T>.CompareExchange(T? value, T? comparand) -> T?
Louis.Threading.InterlockedReference<T>.Equals(Louis.Threading.InterlockedReference<T!> other) -> bool
Louis.Threading.InterlockedReference<T>.Equals(T? other) -> bool
Louis.Threading.InterlockedReference<T>.Exchange(T? value) -> T?
Louis.Threading.InterlockedReference<T>.InterlockedReference() -> void
Louis.Threading.InterlockedReference<T>.InterlockedReference(T? value) -> void
Louis.Threading.InterlockedReference<T>.IsNull.get -> bool
Louis.Threading.InterlockedReference<T>.Value.get -> T?
Louis.Threading.InterlockedReference<T>.Value.set -> void
override Louis.IO.ReadOnlyMemoryStream.CanRead.get -> bool
override Louis.IO.ReadOnlyMemoryStream.CanSeek.get -> bool
override Louis.IO.ReadOnlyMemoryStream.CanWrite.get -> bool
override Louis.IO.ReadOnlyMemoryStream.CopyTo(System.IO.Stream! destination, int bufferSize) -> void
override Louis.IO.ReadOnlyMemoryStream.CopyToAsync(System.IO.Stream! destination, int bufferSize, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!
override Louis.IO.ReadOnlyMemoryStream.Flush() -> void
override Louis.IO.ReadOnlyMemoryStream.FlushAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!
override Louis.IO.ReadOnlyMemoryStream.Length.get -> long
override Louis.IO.ReadOnlyMemoryStream.Position.get -> long
override Louis.IO.ReadOnlyMemoryStream.Position.set -> void
override Louis.IO.ReadOnlyMemoryStream.Read(byte[]! buffer, int offset, int count) -> int
override Louis.IO.ReadOnlyMemoryStream.Read(System.Span<byte> buffer) -> int
override Louis.IO.ReadOnlyMemoryStream.ReadAsync(byte[]! buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<int>!
override Louis.IO.ReadOnlyMemoryStream.ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<int>
override Louis.IO.ReadOnlyMemoryStream.ReadByte() -> int
override Louis.IO.ReadOnlyMemoryStream.Seek(long offset, System.IO.SeekOrigin origin) -> long
override Louis.IO.ReadOnlyMemoryStream.SetLength(long value) -> void
override Louis.IO.ReadOnlyMemoryStream.Write(byte[]! buffer, int offset, int count) -> void
override Louis.IO.ReadOnlyMemoryStream.Write(System.ReadOnlySpan<byte> buffer) -> void
override Louis.IO.ReadOnlyMemoryStream.WriteAsync(byte[]! buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!
override Louis.IO.ReadOnlyMemoryStream.WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask
override Louis.IO.ReadOnlyMemoryStream.WriteByte(byte value) -> void
override Louis.Threading.InterlockedReference<T>.Equals(object? obj) -> bool
override Louis.Threading.InterlockedReference<T>.GetHashCode() -> int
override Louis.Threading.InterlockedReference<T>.ToString() -> string!
static Louis.ComponentModel.SimpleStringConverter.AddToTypeDescriptor<T>() -> void
Louis.Threading.AsyncService.StopAndWaitAsync() -> System.Threading.Tasks.Task<bool>!
static Louis.Threading.InterlockedFlag.operator !=(Louis.Threading.InterlockedFlag a, bool b) -> bool
static Louis.Threading.InterlockedFlag.operator ==(Louis.Threading.InterlockedFlag a, bool b) -> bool
static Louis.Threading.InterlockedReference<T>.operator !=(Louis.Threading.InterlockedReference<T!> a, Louis.Threading.InterlockedReference<T!> b) -> bool
static Louis.Threading.InterlockedReference<T>.operator !=(Louis.Threading.InterlockedReference<T!> a, T? b) -> bool
static Louis.Threading.InterlockedReference<T>.operator ==(Louis.Threading.InterlockedReference<T!> a, Louis.Threading.InterlockedReference<T!> b) -> bool
static Louis.Threading.InterlockedReference<T>.operator ==(Louis.Threading.InterlockedReference<T!> a, T? b) -> bool
virtual Louis.Threading.AsyncService.LogSetupCompleted(bool success) -> void
virtual Louis.Threading.AsyncService.SetupAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<bool>
