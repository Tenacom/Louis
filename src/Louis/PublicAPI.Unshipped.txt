#nullable enable
const Louis.Diagnostics.ExceptionHelper.NullText = "<null>" -> string!
const Louis.Diagnostics.ExceptionHelper.ToStringEmptyText = "<empty!>" -> string!
const Louis.Diagnostics.ExceptionHelper.ToStringNullText = "<null!>" -> string!
Louis.AsyncDisposableExtensions
Louis.Collections.EnumerableExtensions
Louis.Diagnostics.CriticalInternalErrorException
Louis.Diagnostics.CriticalInternalErrorException.CriticalInternalErrorException() -> void
Louis.Diagnostics.CriticalInternalErrorException.CriticalInternalErrorException(string! message) -> void
Louis.Diagnostics.CriticalInternalErrorException.CriticalInternalErrorException(string! message, System.Exception? innerException) -> void
Louis.Diagnostics.CriticalInternalErrorException.CriticalInternalErrorException(System.Runtime.Serialization.SerializationInfo! info, System.Runtime.Serialization.StreamingContext context) -> void
Louis.Diagnostics.ExceptionExtensions
Louis.Diagnostics.ExceptionHelper
Louis.Diagnostics.ICriticalError
Louis.Diagnostics.InternalErrorException
Louis.Diagnostics.InternalErrorException.InternalErrorException() -> void
Louis.Diagnostics.InternalErrorException.InternalErrorException(string! message) -> void
Louis.Diagnostics.InternalErrorException.InternalErrorException(string! message, System.Exception? innerException) -> void
Louis.Diagnostics.InternalErrorException.InternalErrorException(System.Runtime.Serialization.SerializationInfo! info, System.Runtime.Serialization.StreamingContext context) -> void
Louis.Diagnostics.SelfCheck
Louis.Diagnostics.StringBuilderExtensions
Louis.DisposingUtility
Louis.Fluency.FluentAction<T, T1, T2>
Louis.Fluency.FluentAction<T, T1>
Louis.Fluency.FluentAction<T>
Louis.Fluency.FluentExtensions
Louis.RangeCheck
Louis.ReadOnlySpanFunc<T>
Louis.Text.CharReadOnlySpanExtensions
Louis.Text.StringBuilderExtensions
Louis.Text.StringExtensions
Louis.Text.StringLiteralKind
Louis.Text.StringLiteralKind.Quoted = 0 -> Louis.Text.StringLiteralKind
Louis.Text.StringLiteralKind.Verbatim = 1 -> Louis.Text.StringLiteralKind
Louis.Text.UnicodeCharacterUtility
Louis.Text.Utf8Utility
Louis.Threading.InterlockedFlag
Louis.Threading.InterlockedFlag.CheckAndSet(bool value) -> bool
Louis.Threading.InterlockedFlag.Equals(Louis.Threading.InterlockedFlag other) -> bool
Louis.Threading.InterlockedFlag.InterlockedFlag() -> void
Louis.Threading.InterlockedFlag.InterlockedFlag(bool value) -> void
Louis.Threading.InterlockedFlag.TryReset() -> bool
Louis.Threading.InterlockedFlag.TrySet() -> bool
Louis.Threading.InterlockedFlag.TrySet(bool value) -> bool
Louis.Threading.InterlockedFlag.Value.get -> bool
Louis.Threading.InterlockedFlag.Value.set -> void
Louis.Threading.ValueTaskUtility
override Louis.Threading.InterlockedFlag.Equals(object? obj) -> bool
override Louis.Threading.InterlockedFlag.GetHashCode() -> int
override Louis.Threading.InterlockedFlag.ToString() -> string!
static Louis.AsyncDisposableExtensions.DisposeSynchronously(this System.IAsyncDisposable! this) -> void
static Louis.Collections.EnumerableExtensions.DisposeAll(this System.Collections.IEnumerable! this) -> void
static Louis.Collections.EnumerableExtensions.DisposeAllAsync(this System.Collections.IEnumerable! this) -> System.Threading.Tasks.ValueTask
static Louis.Collections.EnumerableExtensions.WhereNot<T>(this System.Collections.Generic.IEnumerable<T>! this, System.Func<T, bool>! predicate) -> System.Collections.Generic.IEnumerable<T>!
static Louis.Collections.EnumerableExtensions.WhereNotNull<T>(this System.Collections.Generic.IEnumerable<T?>! this) -> System.Collections.Generic.IEnumerable<T!>!
static Louis.Collections.EnumerableExtensions.WhereNotNull<T>(this System.Collections.Generic.IEnumerable<T?>! this) -> System.Collections.Generic.IEnumerable<T>!
static Louis.Collections.EnumerableExtensions.WhereNotNullOrEmpty(this System.Collections.Generic.IEnumerable<string?>! this) -> System.Collections.Generic.IEnumerable<string!>!
static Louis.Collections.EnumerableExtensions.WhereNotNullOrWhiteSpace(this System.Collections.Generic.IEnumerable<string?>! this) -> System.Collections.Generic.IEnumerable<string!>!
static Louis.Diagnostics.ExceptionExtensions.AnyCausingException(this System.Exception! this, System.Func<System.Exception!, bool>! predicate) -> bool
static Louis.Diagnostics.ExceptionExtensions.GetCausingExceptions(this System.Exception! this) -> System.Collections.Generic.IEnumerable<System.Exception!>!
static Louis.Diagnostics.ExceptionExtensions.IsCriticalError(this System.Exception! this) -> bool
static Louis.Diagnostics.ExceptionExtensions.Rethrow(this System.Exception! this) -> void
static Louis.Diagnostics.ExceptionHelper.FormatObject(object? obj, string? format = null) -> string!
static Louis.Diagnostics.SelfCheck.CriticalFailure(string! message, string! filePath = "", int lineNumber = 0) -> Louis.Diagnostics.CriticalInternalErrorException!
static Louis.Diagnostics.SelfCheck.Fail(string! message, string! filePath = "", int lineNumber = 0) -> void
static Louis.Diagnostics.SelfCheck.Fail<T>(string! message, string! filePath = "", int lineNumber = 0) -> T
static Louis.Diagnostics.SelfCheck.FailCritically(string! message, string! filePath = "", int lineNumber = 0) -> void
static Louis.Diagnostics.SelfCheck.FailCritically<T>(string! message, string! filePath = "", int lineNumber = 0) -> T
static Louis.Diagnostics.SelfCheck.Failure(string! message, string! filePath = "", int lineNumber = 0) -> Louis.Diagnostics.InternalErrorException!
static Louis.Diagnostics.StringBuilderExtensions.AppendFormattedObject(this System.Text.StringBuilder! this, object? obj, string? format = null) -> System.Text.StringBuilder!
static Louis.DisposingUtility.Dispose(object? obj) -> void
static Louis.DisposingUtility.Dispose(params object?[]! items) -> void
static Louis.DisposingUtility.DisposeAsync(object? obj) -> System.Threading.Tasks.ValueTask
static Louis.DisposingUtility.DisposeAsync(params object?[]! items) -> System.Threading.Tasks.ValueTask
static Louis.Fluency.FluentExtensions.ForEach<T, TElement>(this T this, System.Collections.Generic.IEnumerable<TElement>! sequence, Louis.Fluency.FluentAction<T, TElement, int>! action) -> T
static Louis.Fluency.FluentExtensions.ForEach<T, TElement>(this T this, System.Collections.Generic.IEnumerable<TElement>! sequence, Louis.Fluency.FluentAction<T, TElement>! action) -> T
static Louis.Fluency.FluentExtensions.ForEach<T, TElement>(this T this, System.Collections.Generic.IEnumerable<TElement>! sequence, System.Action<T, TElement, int>! action) -> T
static Louis.Fluency.FluentExtensions.ForEach<T, TElement>(this T this, System.Collections.Generic.IEnumerable<TElement>! sequence, System.Action<T, TElement>! action) -> T
static Louis.Fluency.FluentExtensions.ForEach<T, TElement>(this T this, System.ReadOnlySpan<TElement> span, Louis.Fluency.FluentAction<T, TElement, int>! action) -> T
static Louis.Fluency.FluentExtensions.ForEach<T, TElement>(this T this, System.ReadOnlySpan<TElement> span, Louis.Fluency.FluentAction<T, TElement>! action) -> T
static Louis.Fluency.FluentExtensions.ForEach<T, TElement>(this T this, System.ReadOnlySpan<TElement> span, System.Action<T, TElement, int>! action) -> T
static Louis.Fluency.FluentExtensions.ForEach<T, TElement>(this T this, System.ReadOnlySpan<TElement> span, System.Action<T, TElement>! action) -> T
static Louis.Fluency.FluentExtensions.If<T>(this T this, bool condition, Louis.Fluency.FluentAction<T>! then) -> T
static Louis.Fluency.FluentExtensions.If<T>(this T this, bool condition, System.Action<T>! then) -> T
static Louis.Fluency.FluentExtensions.IfElse<T>(this T this, bool condition, Louis.Fluency.FluentAction<T>! then, Louis.Fluency.FluentAction<T>! else) -> T
static Louis.Fluency.FluentExtensions.IfElse<T>(this T this, bool condition, System.Action<T>! then, System.Action<T>! else) -> T
static Louis.Fluency.FluentExtensions.IfNotNull<T, T1>(this T this, T1? arg, Louis.Fluency.FluentAction<T, T1>! then) -> T
static Louis.Fluency.FluentExtensions.IfNotNull<T, T1>(this T this, T1? arg, System.Action<T, T1>! then) -> T
static Louis.Fluency.FluentExtensions.Invoke<T>(this T this, System.Action<T>! action) -> T
static Louis.Fluency.FluentExtensions.Switch<T, TValue>(this T this, TValue value, Louis.Fluency.FluentAction<T>? default, params (TValue Comparand, Louis.Fluency.FluentAction<T>? Action)[]! cases) -> T
static Louis.Fluency.FluentExtensions.Switch<T, TValue>(this T this, TValue value, Louis.Fluency.FluentAction<T>? default, params (TValue Comparand, System.Action<T>? Action)[]! cases) -> T
static Louis.Fluency.FluentExtensions.Switch<T, TValue>(this T this, TValue value, params (TValue Comparand, Louis.Fluency.FluentAction<T>? Action)[]! cases) -> T
static Louis.Fluency.FluentExtensions.Switch<T, TValue>(this T this, TValue value, params (TValue Comparand, System.Action<T>? Action)[]! cases) -> T
static Louis.RangeCheck.Clamp<T>(T value, T min, T max) -> T
static Louis.RangeCheck.Clamp<T>(T value, T min, T max, System.Collections.Generic.IComparer<T>! comparer) -> T
static Louis.RangeCheck.ClampOrNull<T>(T? value, T min, T max) -> T?
static Louis.RangeCheck.ClampOrNull<T>(T? value, T min, T max, System.Collections.Generic.IComparer<T>! comparer) -> T?
static Louis.RangeCheck.ClampOrNull<T>(T? value, T! min, T! max) -> T?
static Louis.RangeCheck.ClampOrNull<T>(T? value, T! min, T! max, System.Collections.Generic.IComparer<T!>! comparer) -> T?
static Louis.RangeCheck.InRangeOrDefault<T>(T value, T min, T max, T defaultValue) -> T
static Louis.RangeCheck.InRangeOrDefault<T>(T value, T min, T max, T defaultValue, System.Collections.Generic.IComparer<T>! comparer) -> T
static Louis.RangeCheck.InRangeOrDefault<T>(T? value, T min, T max, T? defaultValue, bool acceptNull) -> T?
static Louis.RangeCheck.InRangeOrDefault<T>(T? value, T min, T max, T? defaultValue, bool acceptNull, System.Collections.Generic.IComparer<T>! comparer) -> T?
static Louis.RangeCheck.InRangeOrDefault<T>(T? value, T! min, T! max, T? defaultValue, bool acceptNull) -> T?
static Louis.RangeCheck.InRangeOrDefault<T>(T? value, T! min, T! max, T? defaultValue, bool acceptNull, System.Collections.Generic.IComparer<T!>! comparer) -> T?
static Louis.RangeCheck.Verify<T>(T value, T min, T max) -> bool
static Louis.RangeCheck.Verify<T>(T value, T min, T max, System.Collections.Generic.IComparer<T>! comparer) -> bool
static Louis.RangeCheck.Verify<T>(T? value, T min, T max, bool acceptNull) -> bool
static Louis.RangeCheck.Verify<T>(T? value, T min, T max, bool acceptNull, System.Collections.Generic.IComparer<T>! comparer) -> bool
static Louis.RangeCheck.Verify<T>(T? value, T! min, T! max, bool acceptNull) -> bool
static Louis.RangeCheck.Verify<T>(T? value, T! min, T! max, bool acceptNull, System.Collections.Generic.IComparer<T!>! comparer) -> bool
static Louis.Text.CharReadOnlySpanExtensions.GetLiteralLength(this System.ReadOnlySpan<char> this, Louis.Text.StringLiteralKind literalKind) -> int
static Louis.Text.CharReadOnlySpanExtensions.GetQuotedLiteralLength(this System.ReadOnlySpan<char> this) -> int
static Louis.Text.CharReadOnlySpanExtensions.GetVerbatimLiteralLength(this System.ReadOnlySpan<char> this) -> int
static Louis.Text.CharReadOnlySpanExtensions.ToClippedLiteral(this System.ReadOnlySpan<char> this, Louis.Text.StringLiteralKind literalKind, int headLength, int tailLength, bool useUnicodeEllipsis = false) -> string!
static Louis.Text.CharReadOnlySpanExtensions.ToClippedQuotedLiteral(this System.ReadOnlySpan<char> this, int headLength, int tailLength, bool useUnicodeEllipsis = false) -> string!
static Louis.Text.CharReadOnlySpanExtensions.ToClippedVerbatimLiteral(this System.ReadOnlySpan<char> this, int headLength, int tailLength, bool useUnicodeEllipsis = false) -> string!
static Louis.Text.CharReadOnlySpanExtensions.ToLiteral(this System.ReadOnlySpan<char> this, Louis.Text.StringLiteralKind literalKind) -> string!
static Louis.Text.CharReadOnlySpanExtensions.ToQuotedLiteral(this System.ReadOnlySpan<char> this) -> string!
static Louis.Text.CharReadOnlySpanExtensions.ToVerbatimLiteral(this System.ReadOnlySpan<char> this) -> string!
static Louis.Text.StringBuilderExtensions.AppendClippedLiteral(this System.Text.StringBuilder! this, Louis.Text.StringLiteralKind literalKind, string? str, int headLength, int tailLength) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendClippedLiteral(this System.Text.StringBuilder! this, Louis.Text.StringLiteralKind literalKind, string? str, int headLength, int tailLength, bool useUnicodeEllipsis) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendClippedLiteral(this System.Text.StringBuilder! this, Louis.Text.StringLiteralKind literalKind, System.ReadOnlySpan<char> chars, int headLength, int tailLength) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendClippedLiteral(this System.Text.StringBuilder! this, Louis.Text.StringLiteralKind literalKind, System.ReadOnlySpan<char> chars, int headLength, int tailLength, bool useUnicodeEllipsis) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendClippedQuotedLiteral(this System.Text.StringBuilder! this, string? str, int headLength, int tailLength) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendClippedQuotedLiteral(this System.Text.StringBuilder! this, string? str, int headLength, int tailLength, bool useUnicodeEllipsis) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendClippedQuotedLiteral(this System.Text.StringBuilder! this, System.ReadOnlySpan<char> chars, int headLength, int tailLength) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendClippedQuotedLiteral(this System.Text.StringBuilder! this, System.ReadOnlySpan<char> chars, int headLength, int tailLength, bool useUnicodeEllipsis) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendClippedVerbatimLiteral(this System.Text.StringBuilder! this, string? str, int headLength, int tailLength) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendClippedVerbatimLiteral(this System.Text.StringBuilder! this, string? str, int headLength, int tailLength, bool useUnicodeEllipsis) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendClippedVerbatimLiteral(this System.Text.StringBuilder! this, System.ReadOnlySpan<char> chars, int headLength, int tailLength) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendClippedVerbatimLiteral(this System.Text.StringBuilder! this, System.ReadOnlySpan<char> chars, int headLength, int tailLength, bool useUnicodeEllipsis) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendLiteral(this System.Text.StringBuilder! this, Louis.Text.StringLiteralKind literalKind, string? str) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendLiteral(this System.Text.StringBuilder! this, Louis.Text.StringLiteralKind literalKind, System.ReadOnlySpan<char> chars) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendQuotedLiteral(this System.Text.StringBuilder! this, string? str) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendQuotedLiteral(this System.Text.StringBuilder! this, System.ReadOnlySpan<char> chars) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendResult(this System.Text.StringBuilder! this, Louis.ReadOnlySpanFunc<char>! func) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendResult(this System.Text.StringBuilder! this, System.Func<string?>! provider) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendVerbatimLiteral(this System.Text.StringBuilder! this, string? str) -> System.Text.StringBuilder!
static Louis.Text.StringBuilderExtensions.AppendVerbatimLiteral(this System.Text.StringBuilder! this, System.ReadOnlySpan<char> chars) -> System.Text.StringBuilder!
static Louis.Text.StringExtensions.GetLiteralLength(this string? this, Louis.Text.StringLiteralKind literalKind) -> int
static Louis.Text.StringExtensions.GetQuotedLiteralLength(this string? this) -> int
static Louis.Text.StringExtensions.GetVerbatimLiteralLength(this string? this) -> int
static Louis.Text.StringExtensions.ToClippedLiteral(this string? this, Louis.Text.StringLiteralKind literalKind, int headLength, int tailLength, bool useUnicodeEllipsis = false) -> string!
static Louis.Text.StringExtensions.ToClippedQuotedLiteral(this string? this, int headLength, int tailLength, bool useUnicodeEllipsis = false) -> string!
static Louis.Text.StringExtensions.ToClippedVerbatimLiteral(this string? this, int headLength, int tailLength, bool useUnicodeEllipsis = false) -> string!
static Louis.Text.StringExtensions.ToLiteral(this string? this, Louis.Text.StringLiteralKind literalKind) -> string!
static Louis.Text.StringExtensions.ToQuotedLiteral(this string? this) -> string!
static Louis.Text.StringExtensions.ToVerbatimLiteral(this string? this) -> string!
static Louis.Text.UnicodeCharacterUtility.IsIdentifierPartCharacter(char ch) -> bool
static Louis.Text.UnicodeCharacterUtility.IsIdentifierStartCharacter(char ch) -> bool
static Louis.Text.UnicodeCharacterUtility.IsValidIdentifier(string? name) -> bool
static Louis.Text.UnicodeCharacterUtility.IsValidIdentifier(System.ReadOnlySpan<char> name) -> bool
static Louis.Text.Utf8Utility.GetMaxCharsInBytes(string! str, int maxBytes) -> int
static Louis.Text.Utf8Utility.GetMaxCharsInBytes(System.ReadOnlySpan<char> chars, int maxBytes) -> int
static Louis.Threading.InterlockedFlag.operator !=(Louis.Threading.InterlockedFlag a, Louis.Threading.InterlockedFlag b) -> bool
static Louis.Threading.InterlockedFlag.operator ==(Louis.Threading.InterlockedFlag a, Louis.Threading.InterlockedFlag b) -> bool
static Louis.Threading.ValueTaskUtility.WhenAll(params System.Threading.Tasks.ValueTask[]! valueTasks) -> System.Threading.Tasks.ValueTask
static Louis.Threading.ValueTaskUtility.WhenAll(System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask>! valueTasks) -> System.Threading.Tasks.ValueTask
static readonly Louis.Text.Utf8Utility.Utf8NoBomEncoding -> System.Text.Encoding!
